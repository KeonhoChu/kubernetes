
# ConfigMap과 Secret

## 설정이 왜 중요한가?

### 현실 세계의 비유
**ConfigMap과 Secret**은 **사무실의 설정 파일함**과 비슷합니다:
- **ConfigMap**: 모든 직원이 볼 수 있는 공개 설정 (회사 규정, 업무 가이드)
- **Secret**: 금고에 보관하는 민감한 정보 (비밀번호, 열쇠, 계약서)

### 왜 분리해야 할까?
```
❌ 잘못된 방식: 코드에 설정을 하드코딩
image: myapp:1.0
env:
  - DB_HOST: "192.168.1.100"  # 개발환경에서만 동작
  - PASSWORD: "admin123"      # 코드에 비밀번호 노출!

✅ 올바른 방식: 설정을 외부로 분리
image: myapp:1.0
env:
  - DB_HOST: 
      valueFrom:
        configMapKeyRef: ...
  - PASSWORD:
      valueFrom:
        secretKeyRef: ...
```

## ConfigMap 이해하기

### ConfigMap이란?
- **목적**: 애플리케이션의 **공개 설정**을 저장
- **사용 예시**: 서버 포트, API URL, 로그 레벨 등
- **특징**: 평문으로 저장되므로 누구나 볼 수 있음

### ConfigMap 활용 방법
1. **환경 변수**로 주입
2. **파일**로 마운트
3. **명령줄 인수**로 전달

## Secret 이해하기

### Secret이란?
- **목적**: **민감한 정보**를 안전하게 저장
- **사용 예시**: 데이터베이스 비밀번호, API 키, 인증서
- **특징**: Base64 인코딩되어 저장 (암호화 아님!)

### Secret 타입들
```yaml
# 일반적인 Secret
type: Opaque

# Docker 레지스트리 인증
type: kubernetes.io/dockerconfigjson

# TLS 인증서
type: kubernetes.io/tls

# 서비스 어카운트 토큰
type: kubernetes.io/service-account-token
```

## 실습: ConfigMap 만들어보기

### 1. 명령어로 생성
```bash
# 키-값 쌍으로 생성
kubectl create configmap app-config \
  --from-literal=database_url=mysql://example.com:3306/myapp \
  --from-literal=log_level=INFO

# 파일에서 생성
echo "server.port=8080" > app.properties
kubectl create configmap app-config-file --from-file=app.properties

# 전체 디렉토리에서 생성
kubectl create configmap app-config-dir --from-file=./config/
```

### 2. YAML 파일로 생성
```yaml
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: web-config
data:
  # 환경 변수로 사용할 설정들
  APP_NAME: "MyWebApp"
  APP_VERSION: "1.0.0"
  LOG_LEVEL: "DEBUG"
  
  # 파일로 마운트할 설정
  nginx.conf: |
    server {
        listen 80;
        server_name localhost;
        location / {
            root /usr/share/nginx/html;
            index index.html;
        }
    }
```

```bash
kubectl apply -f configmap.yaml
```

### 3. ConfigMap 확인
```bash
# ConfigMap 목록 보기
kubectl get configmap

# ConfigMap 내용 보기
kubectl describe configmap web-config

# YAML 형태로 보기
kubectl get configmap web-config -o yaml
```

## 실습: Secret 만들어보기

### 1. 명령어로 생성
```bash
# 키-값으로 생성
kubectl create secret generic app-secret \
  --from-literal=username=admin \
  --from-literal=password=secretpassword

# 파일에서 생성
echo -n 'admin' > username.txt
echo -n 'secretpassword' > password.txt
kubectl create secret generic app-secret-file \
  --from-file=username.txt \
  --from-file=password.txt
```

### 2. YAML 파일로 생성
```yaml
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: database-secret
type: Opaque
data:
  # Base64로 인코딩된 값들 (echo -n "value" | base64)
  db-username: cm9vdA==      # "root"
  db-password: bXlwYXNzd29yZA==  # "mypassword"
  api-token: YWJjZGVmZ2hpams=    # "abcdefghijk"
```

```bash
kubectl apply -f secret.yaml
```

### 3. Secret 확인
```bash
# Secret 목록 보기
kubectl get secret

# Secret 내용 보기 (값은 숨겨짐)
kubectl describe secret database-secret

# 실제 값 확인 (주의: 평문으로 보임!)
kubectl get secret database-secret -o yaml
```

## Pod에서 ConfigMap과 Secret 사용하기

### 1. 환경 변수로 사용
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-app
spec:
  containers:
  - name: nginx
    image: nginx:1.20
    env:
    # ConfigMap에서 환경 변수 가져오기
    - name: APP_NAME
      valueFrom:
        configMapKeyRef:
          name: web-config
          key: APP_NAME
    
    # Secret에서 환경 변수 가져오기
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: database-secret
          key: db-password
    
    # 전체 ConfigMap을 환경 변수로 가져오기
    envFrom:
    - configMapRef:
        name: web-config
    - secretRef:
        name: database-secret
```

### 2. 볼륨으로 마운트
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-app-with-volume
spec:
  containers:
  - name: nginx
    image: nginx:1.20
    volumeMounts:
    # ConfigMap을 파일로 마운트
    - name: config-volume
      mountPath: /etc/nginx/nginx.conf
      subPath: nginx.conf
    
    # Secret을 파일로 마운트
    - name: secret-volume
      mountPath: /etc/secrets
      readOnly: true
  
  volumes:
  - name: config-volume
    configMap:
      name: web-config
  - name: secret-volume
    secret:
      secretName: database-secret
```

### 3. Deployment에서 사용
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - name: web-app
        image: nginx:1.20
        env:
        - name: DATABASE_URL
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: database_url
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secret
              key: password
```

## 실제 사용 시나리오

### 시나리오 1: 웹 애플리케이션 설정
```yaml
# 개발 환경 ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: web-config-dev
data:
  APP_ENV: "development"
  DEBUG: "true"
  API_URL: "http://api-dev.example.com"
  
---
# 운영 환경 ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: web-config-prod
data:
  APP_ENV: "production"
  DEBUG: "false"
  API_URL: "https://api.example.com"
```

### 시나리오 2: 데이터베이스 연결 설정
```yaml
# ConfigMap: 공개 설정
apiVersion: v1
kind: ConfigMap
metadata:
  name: db-config
data:
  DB_HOST: "mysql.default.svc.cluster.local"
  DB_PORT: "3306"
  DB_NAME: "myapp"
  
---
# Secret: 민감한 정보
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque
data:
  DB_USER: cm9vdA==           # root
  DB_PASSWORD: bXlwYXNzd29yZA==  # mypassword
```

## 설정 업데이트하기

### ConfigMap 업데이트
```bash
# 설정 값 변경
kubectl patch configmap web-config -p '{"data":{"LOG_LEVEL":"ERROR"}}'

# 파일에서 업데이트
kubectl create configmap web-config --from-file=new-config.properties --dry-run=client -o yaml | kubectl apply -f -
```

### Pod에 변경사항 반영
```bash
# Deployment 재시작 (설정 변경 반영)
kubectl rollout restart deployment web-deployment

# 특정 Pod 재시작
kubectl delete pod web-app
```

## 보안 고려사항

### Secret 보안 강화
```yaml
# Secret 볼륨을 메모리에 마운트 (디스크에 저장하지 않음)
volumes:
- name: secret-volume
  secret:
    secretName: app-secret
    defaultMode: 0400  # 읽기 전용
```

### 접근 권한 제한
```yaml
# RBAC로 Secret 접근 제한
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secret-reader
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list"]
```

## 고급 사용법

### 1. 선택적 키 사용
```yaml
env:
- name: SPECIFIC_CONFIG
  valueFrom:
    configMapKeyRef:
      name: app-config
      key: specific_key
      optional: true  # 키가 없어도 오류 발생하지 않음
```

### 2. 파일 권한 설정
```yaml
volumes:
- name: config-volume
  configMap:
    name: app-config
    defaultMode: 0644  # 파일 권한 설정
    items:
    - key: config.json
      path: app-config.json
      mode: 0600
```

### 3. 불변(Immutable) ConfigMap
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: immutable-config
data:
  app.properties: "key=value"
immutable: true  # 한 번 생성하면 변경 불가
```

## 문제 해결

### 일반적인 문제들

#### 1. ConfigMap이 Pod에 반영되지 않음
```bash
# ConfigMap 존재 확인
kubectl get configmap

# Pod 환경 변수 확인
kubectl exec pod-name -- env

# Pod 내부 파일 확인
kubectl exec pod-name -- cat /path/to/config/file
```

#### 2. Secret 값이 잘못됨
```bash
# Secret 값 디코딩해서 확인
kubectl get secret app-secret -o jsonpath='{.data.password}' | base64 -d
```

#### 3. 설정 변경이 반영되지 않음
```bash
# ConfigMap 변경 시간 확인
kubectl describe configmap app-config

# Pod 재시작
kubectl rollout restart deployment app-deployment
```

## 모범 사례

### 1. 네이밍 규칙
```bash
# 환경별 구분
app-config-dev
app-config-staging
app-config-prod

# 용도별 구분
app-database-config
app-logging-config
app-cache-config
```

### 2. 조직화
```yaml
# 관련 설정들을 하나의 ConfigMap으로 그룹화
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-database-config
  labels:
    app: myapp
    component: database
data:
  host: "db.example.com"
  port: "5432"
  pool_size: "10"
```

### 3. 문서화
```yaml
metadata:
  name: app-config
  annotations:
    description: "Main application configuration"
    version: "1.2.0"
    updated-by: "admin@example.com"
```

## 다음 단계
설정 관리를 마스터했다면 [[Volume과 Storage]]를 통해 데이터를 영구적으로 저장하는 방법을 알아보세요!

