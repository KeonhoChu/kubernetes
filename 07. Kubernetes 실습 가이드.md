
# Kubernetes 실습 가이드

## 🎯 실습 목표
이 가이드는 **실제 시나리오**를 통해 Kubernetes의 핵심 개념들을 단계별로 실습해보는 것을 목적으로 합니다. 이론을 배우고 난 후 **실전 경험**을 쌓을 수 있도록 구성했습니다.

## 🛠 사전 준비

### 필수 도구
```bash
# Kubernetes 클러스터 (하나만 선택)
- Docker Desktop (Windows/Mac)
- minikube (Linux/Mac/Windows)
- kind (Kubernetes in Docker)

# 기본 도구
- kubectl (Kubernetes CLI)
- Docker (컨테이너 이미지 빌드용)
```

### 환경 확인
```bash
# Kubernetes 클러스터 상태 확인
kubectl cluster-info

# 노드 확인
kubectl get nodes

# kubectl 버전 확인
kubectl version --client
```

## 실습 1: 기본 웹 애플리케이션 배포

### 목표
- Pod, Service, Deployment의 기본 사용법 익히기
- 간단한 웹 애플리케이션 배포 및 접근
- 스케일링 실습

### 1단계: 기본 Pod 생성
```yaml
# simple-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-pod
  labels:
    app: web
spec:
  containers:
  - name: nginx
    image: nginx:1.20
    ports:
    - containerPort: 80
    resources:
      requests:
        memory: "128Mi"
        cpu: "250m"
      limits:
        memory: "256Mi"
        cpu: "500m"
```

```bash
# Pod 생성
kubectl apply -f simple-pod.yaml

# Pod 상태 확인
kubectl get pods
kubectl describe pod web-pod

# Pod 로그 확인
kubectl logs web-pod
```

### 2단계: Service로 외부 접근 설정
```yaml
# web-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: web-service
spec:
  selector:
    app: web
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30080
  type: NodePort
```

```bash
# Service 생성
kubectl apply -f web-service.yaml

# Service 확인
kubectl get services
kubectl describe service web-service

# 외부에서 접근 (minikube의 경우)
minikube service web-service --url
```

### 3단계: Deployment로 확장
```yaml
# web-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - name: nginx
        image: nginx:1.20
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "128Mi"
            cpu: "250m"
          limits:
            memory: "256Mi"
            cpu: "500m"
```

```bash
# 기존 Pod 삭제
kubectl delete pod web-pod

# Deployment 생성
kubectl apply -f web-deployment.yaml

# Deployment 상태 확인
kubectl get deployments
kubectl get pods

# 스케일링 테스트
kubectl scale deployment web-deployment --replicas=5
kubectl get pods -w

# 스케일 다운
kubectl scale deployment web-deployment --replicas=2
```

## 실습 2: 데이터베이스와 연동된 웹 애플리케이션

### 목표
- ConfigMap과 Secret 활용
- 영구 볼륨(PV/PVC) 사용
- 다중 서비스 연동

### 1단계: MySQL 설정 준비
```yaml
# mysql-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
data:
  MYSQL_DATABASE: "wordpress"

---
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  MYSQL_ROOT_PASSWORD: cm9vdHBhc3N3b3Jk  # rootpassword
  MYSQL_USER: d29yZHByZXNz              # wordpress
  MYSQL_PASSWORD: d29yZHByZXNz          # wordpress
```

```bash
# 설정 배포
kubectl apply -f mysql-config.yaml

# 설정 확인
kubectl get configmap
kubectl get secret
```

### 2단계: MySQL PVC 및 Deployment
```yaml
# mysql-storage.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi

---
# mysql-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_DATABASE
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_ROOT_PASSWORD
        - name: MYSQL_USER
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_USER
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_PASSWORD
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pvc

---
# mysql-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
spec:
  selector:
    app: mysql
  ports:
    - port: 3306
      targetPort: 3306
  type: ClusterIP
```

### 3단계: 웹 애플리케이션 업데이트
```yaml
# web-app-with-db.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app-db
spec:
  replicas: 2
  selector:
    matchLabels:
      app: web-db
  template:
    metadata:
      labels:
        app: web-db
    spec:
      containers:
      - name: web-app
        image: wordpress:latest
        ports:
        - containerPort: 80
        env:
        - name: WORDPRESS_DB_HOST
          value: "mysql-service:3306"
        - name: WORDPRESS_DB_NAME
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_DATABASE
        - name: WORDPRESS_DB_USER
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_USER
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: MYSQL_PASSWORD
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"

---
apiVersion: v1
kind: Service
metadata:
  name: web-app-db-service
spec:
  selector:
    app: web-db
  ports:
    - port: 80
      targetPort: 80
  type: LoadBalancer
```

### 4단계: 전체 배포 및 테스트
```bash
# 순서대로 배포
kubectl apply -f mysql-config.yaml
kubectl apply -f mysql-storage.yaml
kubectl apply -f web-app-with-db.yaml

# 배포 상태 확인
kubectl get all

# MySQL 준비 상태 확인
kubectl get pods -l app=mysql
kubectl logs deployment/mysql

# 웹 애플리케이션 접근
minikube service web-app-db-service --url
```

## 실습 3: 마이크로서비스 아키텍처

### 목표
- 여러 마이크로서비스 배포
- 서비스 간 통신 설정
- Ingress를 통한 라우팅
- 모니터링 및 로깅

### 1단계: Frontend 서비스
```yaml
# frontend.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: nginx:1.20
        ports:
        - containerPort: 80
        volumeMounts:
        - name: frontend-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
      volumes:
      - name: frontend-config
        configMap:
          name: frontend-config

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-config
data:
  nginx.conf: |
    events {
        worker_connections 1024;
    }
    http {
        upstream backend {
            server backend-service:8080;
        }
        upstream api {
            server api-service:8080;
        }
        server {
            listen 80;
            location / {
                proxy_pass http://backend;
            }
            location /api/ {
                proxy_pass http://api/;
            }
        }
    }

---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  selector:
    app: frontend
  ports:
    - port: 80
      targetPort: 80
```

### 2단계: Backend 서비스
```yaml
# backend.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: httpd:2.4
        ports:
        - containerPort: 80
        env:
        - name: API_URL
          value: "http://api-service:8080"
        resources:
          requests:
            memory: "128Mi"
            cpu: "250m"
          limits:
            memory: "256Mi"
            cpu: "500m"

---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
spec:
  selector:
    app: backend
  ports:
    - port: 8080
      targetPort: 80
```

### 3단계: API 서비스
```yaml
# api.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
spec:
  replicas: 2
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
      - name: api
        image: node:16-alpine
        command: ["node", "-e", "
          const http = require('http');
          const server = http.createServer((req, res) => {
            res.writeHead(200, {'Content-Type': 'application/json'});
            res.end(JSON.stringify({message: 'Hello from API', timestamp: new Date()}));
          });
          server.listen(8080, () => console.log('API server running on port 8080'));
        "]
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          value: "mysql://mysql-service:3306/myapp"

---
apiVersion: v1
kind: Service
metadata:
  name: api-service
spec:
  selector:
    app: api
  ports:
    - port: 8080
      targetPort: 8080
```

### 4단계: Ingress 설정
```yaml
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: myapp.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 8080
```

## 실습 4: 애플리케이션 업데이트 및 롤백

### 목표
- Rolling Update 실습
- 업데이트 모니터링
- 롤백 수행
- Health Check 설정

### 1단계: Health Check가 있는 애플리케이션
```yaml
# app-with-healthcheck.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: healthy-app
spec:
  replicas: 4
  selector:
    matchLabels:
      app: healthy-app
  template:
    metadata:
      labels:
        app: healthy-app
    spec:
      containers:
      - name: app
        image: nginx:1.20
        ports:
        - containerPort: 80
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        resources:
          requests:
            memory: "128Mi"
            cpu: "250m"
          limits:
            memory: "256Mi"
            cpu: "500m"
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
```

### 2단계: 업데이트 실습
```bash
# 초기 배포
kubectl apply -f app-with-healthcheck.yaml

# 배포 상태 모니터링
kubectl get deployments -w

# 새 버전으로 업데이트
kubectl set image deployment/healthy-app app=nginx:1.21

# 업데이트 진행 상황 실시간 확인
kubectl rollout status deployment/healthy-app

# 업데이트 히스토리 확인
kubectl rollout history deployment/healthy-app
```

### 3단계: 의도적 실패 및 롤백
```bash
# 잘못된 이미지로 업데이트 (실패 상황 연출)
kubectl set image deployment/healthy-app app=nginx:nonexistent

# 실패 상황 모니터링
kubectl get pods
kubectl describe deployment healthy-app

# 즉시 롤백
kubectl rollout undo deployment/healthy-app

# 특정 버전으로 롤백
kubectl rollout undo deployment/healthy-app --to-revision=1
```

## 실습 5: 모니터링 및 로깅

### 목표
- 리소스 사용량 모니터링
- 로그 수집 및 분석
- 메트릭 수집

### 1단계: 리소스 모니터링
```bash
# Metrics Server 설치 (minikube)
minikube addons enable metrics-server

# 노드 리소스 확인
kubectl top nodes

# Pod 리소스 확인
kubectl top pods

# 특정 네임스페이스의 Pod들
kubectl top pods -n kube-system
```

### 2단계: 로그 수집 설정
```yaml
# log-generator.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: log-generator
spec:
  replicas: 2
  selector:
    matchLabels:
      app: log-generator
  template:
    metadata:
      labels:
        app: log-generator
    spec:
      containers:
      - name: logger
        image: busybox
        command: ["sh", "-c"]
        args:
        - while true; do
            echo "$(date): Application log message from $(hostname)";
            sleep 10;
          done
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
```

### 3단계: 로그 확인 및 분석
```bash
# 개별 Pod 로그 확인
kubectl logs deployment/log-generator

# 실시간 로그 스트리밍
kubectl logs -f deployment/log-generator

# 모든 Pod의 로그 확인
kubectl logs -l app=log-generator

# 최근 1시간 로그만 확인
kubectl logs deployment/log-generator --since=1h
```

## 실습 6: 오토스케일링

### 목표
- HPA (Horizontal Pod Autoscaler) 설정
- 부하 테스트
- 자동 확장/축소 확인

### 1단계: CPU 기반 오토스케일링
```yaml
# scalable-app.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: scalable-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: scalable-app
  template:
    metadata:
      labels:
        app: scalable-app
    spec:
      containers:
      - name: app
        image: php:7.4-apache
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: 200m
            memory: "256Mi"
          limits:
            cpu: 500m
            memory: "512Mi"

---
apiVersion: v1
kind: Service
metadata:
  name: scalable-app-service
spec:
  selector:
    app: scalable-app
  ports:
    - port: 80
      targetPort: 80
```

### 2단계: HPA 설정
```bash
# HPA 생성
kubectl autoscale deployment scalable-app --cpu-percent=50 --min=1 --max=10

# HPA 상태 확인
kubectl get hpa
kubectl describe hpa scalable-app
```

### 3단계: 부하 테스트
```bash
# 부하 생성용 Pod 실행
kubectl run load-generator --image=busybox --rm -it -- /bin/sh

# Pod 내에서 부하 생성
while true; do wget -q -O- http://scalable-app-service; done

# 다른 터미널에서 스케일링 모니터링
kubectl get hpa -w
kubectl get pods -w
```

## 문제 해결 가이드

### 일반적인 문제 해결 절차

#### 1. Pod가 시작되지 않는 경우
```bash
# Pod 상태 확인
kubectl get pods
kubectl describe pod <pod-name>

# 이벤트 확인
kubectl get events --sort-by=.metadata.creationTimestamp

# 로그 확인
kubectl logs <pod-name>
```

#### 2. 서비스에 접근할 수 없는 경우
```bash
# 서비스 확인
kubectl get services
kubectl describe service <service-name>

# Endpoint 확인
kubectl get endpoints <service-name>

# 네트워크 연결 테스트
kubectl run test-pod --image=busybox --rm -it -- nslookup <service-name>
```

#### 3. 리소스 부족 문제
```bash
# 노드 리소스 확인
kubectl describe nodes
kubectl top nodes

# Pod 리소스 요청량 확인
kubectl describe pods
```

### 일반적인 명령어 모음
```bash
# 전체 상태 확인
kubectl get all

# 디버깅용 명령어
kubectl top pods --containers
kubectl describe pvc --all-namespaces
```

## 정리 및 다음 단계

### 실습 완료 후 정리
```bash
# 모든 실습 리소스 삭제
kubectl delete deployment --all
kubectl delete service --all
kubectl delete pvc --all
kubectl delete configmap --all
kubectl delete secret --all

# 네임스페이스별 정리
kubectl delete namespace <namespace-name>
```

### 다음 학습 단계
1. **Helm**: 패키지 매니저로 복잡한 애플리케이션 관리
2. **Istio**: 서비스 메시로 마이크로서비스 통신 관리
3. **Prometheus + Grafana**: 모니터링 시스템 구축
4. **CI/CD**: Jenkins, GitLab CI와 Kubernetes 연동
5. **보안**: RBAC, Network Policy, Pod Security Standards

### 추천 다음 실습
- 실제 프로젝트를 Kubernetes에 배포해보기
- 클라우드 환경 (AWS EKS, GCP GKE, Azure AKS)에서 실습
- Production 환경 구성 및 운영 실습

## 참고 자료

### 공식 문서
- [Kubernetes 공식 튜토리얼](https://kubernetes.io/docs/tutorials/)
- [kubectl 치트시트](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)

### 실습 환경
- [Play with Kubernetes](https://labs.play-with-k8s.com/)
- [Katacoda Kubernetes](https://www.katacoda.com/courses/kubernetes)

### 추가 도구
- [k9s](https://k9scli.io/): Kubernetes CLI 대시보드
- [kubectx/kubens](https://github.com/ahmetb/kubectx): 컨텍스트/네임스페이스 전환 도구
- [stern](https://github.com/wercker/stern): 다중 Pod 로그 뷰어

축하합니다! 🎉 Kubernetes 기초 실습을 완료했습니다. 이제 실제 프로젝트에 적용해보세요!

#Kubernetes #실습 #튜토리얼 #실전
